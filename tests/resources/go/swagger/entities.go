// Code generated by github.com/swaggest/go-code-builder, DO NOT EDIT.

package swagger

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
)

// SwaggerSchema structure is generated from "#".
//
// A JSON Schema for Swagger 2.0 API.
type SwaggerSchema struct {
	// General information about the API.
	// Required.
	Info                Info                                               `json:"info"`
	// The host (name or ip) of the API. Example: 'swagger.io'.
	// Value must match pattern: `^[^{}/ :\\]+(?::\d+)?$`.
	Host                string                                             `json:"host,omitempty"`
	// The base path to the API. Example: '/api'.
	// Value must match pattern: `^/`.
	BasePath            string                                             `json:"basePath,omitempty"`
	Schemes             []SchemesListItems                                 `json:"schemes,omitempty"`             // The transfer protocol of the API.
	Consumes            []string                                           `json:"consumes,omitempty"`            // A list of MIME types accepted by the API.
	Produces            []string                                           `json:"produces,omitempty"`            // A list of MIME types the API can produce.
	// Relative paths to the individual endpoints. They must be relative to the 'basePath'.
	// Required.
	Paths               Paths                                              `json:"paths"`
	Definitions         map[string]Schema                                  `json:"definitions,omitempty"`         // One or more JSON objects describing the schemas being consumed and produced by the API.
	Parameters          map[string]Parameter                               `json:"parameters,omitempty"`          // One or more JSON representations for parameters.
	Responses           map[string]Response                                `json:"responses,omitempty"`           // One or more JSON representations for parameters.
	Security            []map[string][]string                              `json:"security,omitempty"`
	SecurityDefinitions map[string]SecurityDefinitionsAdditionalProperties `json:"securityDefinitions,omitempty"`
	Tags                []Tag                                              `json:"tags,omitempty"`
	ExternalDocs        *ExternalDocs                                      `json:"externalDocs,omitempty"`        // Information about external documentation.
	MapOfAnything       map[string]interface{}                             `json:"-"`                             // Key must match pattern: `^x-`.
}

type marshalSwaggerSchema SwaggerSchema

var ignoreKeysSwaggerSchema = []string{
	"info",
	"host",
	"basePath",
	"schemes",
	"consumes",
	"produces",
	"paths",
	"definitions",
	"parameters",
	"responses",
	"security",
	"securityDefinitions",
	"tags",
	"externalDocs",
	"swagger",
}

// UnmarshalJSON decodes JSON.
func (s *SwaggerSchema) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSwaggerSchema(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["swagger"]; !ok || string(v) != `"2.0"` {
		return fmt.Errorf(`bad or missing const value for "swagger" ("2.0" expected, %s received)`, v)
	}

	delete(rawMap, "swagger")

	for _, key := range ignoreKeysSwaggerSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*s = SwaggerSchema(ms)

	return nil
}

var (
	// constSwaggerSchema is unconditionally added to JSON.
	constSwaggerSchema = json.RawMessage(`{"swagger":"2.0"}`)
)

// MarshalJSON encodes JSON.
func (s SwaggerSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSwaggerSchema, marshalSwaggerSchema(s), s.MapOfAnything)
}

// Info structure is generated from "#/definitions/info".
//
// General information about the API.
type Info struct {
	// A unique and precise title of the API.
	// Required.
	Title          string                 `json:"title"`
	// A semantic version number of the API.
	// Required.
	Version        string                 `json:"version"`
	Description    string                 `json:"description,omitempty"`    // A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.
	TermsOfService string                 `json:"termsOfService,omitempty"` // The terms of service for the API.
	Contact        *Contact               `json:"contact,omitempty"`        // Contact information for the owners of the API.
	License        *License               `json:"license,omitempty"`
	MapOfAnything  map[string]interface{} `json:"-"`                        // Key must match pattern: `^x-`.
}

type marshalInfo Info

var ignoreKeysInfo = []string{
	"title",
	"version",
	"description",
	"termsOfService",
	"contact",
	"license",
}

// UnmarshalJSON decodes JSON.
func (i *Info) UnmarshalJSON(data []byte) error {
	var err error

	mi := marshalInfo(*i)

	err = json.Unmarshal(data, &mi)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mi.MapOfAnything == nil {
				mi.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mi.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*i = Info(mi)

	return nil
}

// MarshalJSON encodes JSON.
func (i Info) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalInfo(i), i.MapOfAnything)
}

// Contact structure is generated from "#/definitions/contact".
//
// Contact information for the owners of the API.
type Contact struct {
	Name          string                 `json:"name,omitempty"`  // The identifying name of the contact person/organization.
	// The URL pointing to the contact information.
	// Format: uri.
	URL           string                 `json:"url,omitempty"`
	// The email address of the contact person/organization.
	// Format: email.
	Email         string                 `json:"email,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`               // Key must match pattern: `^x-`.
}

type marshalContact Contact

var ignoreKeysContact = []string{
	"name",
	"url",
	"email",
}

// UnmarshalJSON decodes JSON.
func (c *Contact) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalContact(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysContact {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*c = Contact(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c Contact) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalContact(c), c.MapOfAnything)
}

// License structure is generated from "#/definitions/license".
type License struct {
	// The name of the license type. It's encouraged to use an OSI compatible license.
	// Required.
	Name          string                 `json:"name"`
	// The URL pointing to the license.
	// Format: uri.
	URL           string                 `json:"url,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`             // Key must match pattern: `^x-`.
}

type marshalLicense License

var ignoreKeysLicense = []string{
	"name",
	"url",
}

// UnmarshalJSON decodes JSON.
func (l *License) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLicense(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysLicense {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ml.MapOfAnything == nil {
				ml.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ml.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*l = License(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l License) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalLicense(l), l.MapOfAnything)
}

// Paths structure is generated from "#/definitions/paths".
//
// Relative paths to the individual endpoints. They must be relative to the 'basePath'.
type Paths struct {
	MapOfAnything       map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
	MapOfPathItemValues map[string]PathItem    `json:"-"` // Key must match pattern: `^/`.
}

// UnmarshalJSON decodes JSON.
func (p *Paths) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if p.MapOfAnything == nil {
				p.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			p.MapOfAnything[key] = val
		}

		if regex.MatchString(key) {
			matched = true

			if p.MapOfPathItemValues == nil {
				p.MapOfPathItemValues = make(map[string]PathItem, 1)
			}

			var val PathItem

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			p.MapOfPathItemValues[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (p Paths) MarshalJSON() ([]byte, error) {
	return marshalUnion(p.MapOfAnything, p.MapOfPathItemValues)
}

// PathItem structure is generated from "#/definitions/pathItem".
type PathItem struct {
	Ref           string                 `json:"$ref,omitempty"`
	Get           *Operation             `json:"get,omitempty"`
	Put           *Operation             `json:"put,omitempty"`
	Post          *Operation             `json:"post,omitempty"`
	Delete        *Operation             `json:"delete,omitempty"`
	Options       *Operation             `json:"options,omitempty"`
	Head          *Operation             `json:"head,omitempty"`
	Patch         *Operation             `json:"patch,omitempty"`
	Parameters    []ParametersListItems  `json:"parameters,omitempty"` // The parameters needed to send a valid API call.
	MapOfAnything map[string]interface{} `json:"-"`                    // Key must match pattern: `^x-`.
}

type marshalPathItem PathItem

var ignoreKeysPathItem = []string{
	"$ref",
	"get",
	"put",
	"post",
	"delete",
	"options",
	"head",
	"patch",
	"parameters",
}

// UnmarshalJSON decodes JSON.
func (p *PathItem) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalPathItem(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysPathItem {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mp.MapOfAnything == nil {
				mp.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mp.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*p = PathItem(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p PathItem) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalPathItem(p), p.MapOfAnything)
}

// Operation structure is generated from "#/definitions/operation".
type Operation struct {
	Tags          []string               `json:"tags,omitempty"`
	Summary       string                 `json:"summary,omitempty"`      // A brief summary of the operation.
	Description   string                 `json:"description,omitempty"`  // A longer description of the operation, GitHub Flavored Markdown is allowed.
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	ID            string                 `json:"operationId,omitempty"`  // A unique identifier of the operation.
	Produces      []string               `json:"produces,omitempty"`     // A list of MIME types the API can produce.
	Consumes      []string               `json:"consumes,omitempty"`     // A list of MIME types the API can consume.
	Parameters    []ParametersListItems  `json:"parameters,omitempty"`   // The parameters needed to send a valid API call.
	// Response objects names can either be any valid HTTP status code or 'default'.
	// Required.
	Responses     Responses              `json:"responses"`
	Schemes       []SchemesListItems     `json:"schemes,omitempty"`      // The transfer protocol of the API.
	Deprecated    bool                   `json:"deprecated,omitempty"`
	Security      []map[string][]string  `json:"security,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-`.
}

type marshalOperation Operation

var ignoreKeysOperation = []string{
	"tags",
	"summary",
	"description",
	"externalDocs",
	"operationId",
	"produces",
	"consumes",
	"parameters",
	"responses",
	"schemes",
	"deprecated",
	"security",
}

// UnmarshalJSON decodes JSON.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOperation(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysOperation {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Operation(mo)

	return nil
}

// MarshalJSON encodes JSON.
func (o Operation) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalOperation(o), o.MapOfAnything)
}

// ExternalDocs structure is generated from "#/definitions/externalDocs".
//
// information about external documentation.
type ExternalDocs struct {
	Description   string                 `json:"description,omitempty"`
	// Format: uri.
	// Required.
	URL           string                 `json:"url"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalExternalDocs ExternalDocs

var ignoreKeysExternalDocs = []string{
	"description",
	"url",
}

// UnmarshalJSON decodes JSON.
func (e *ExternalDocs) UnmarshalJSON(data []byte) error {
	var err error

	me := marshalExternalDocs(*e)

	err = json.Unmarshal(data, &me)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysExternalDocs {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if me.MapOfAnything == nil {
				me.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			me.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*e = ExternalDocs(me)

	return nil
}

// MarshalJSON encodes JSON.
func (e ExternalDocs) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalExternalDocs(e), e.MapOfAnything)
}

// BodyParameter structure is generated from "#/definitions/bodyParameter".
type BodyParameter struct {
	Description   string                 `json:"description,omitempty"` // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	// The name of the parameter.
	// Required.
	Name          string                 `json:"name"`
	Required      bool                   `json:"required,omitempty"`    // Determines whether or not this parameter is required or optional.
	// A deterministic version of a JSON Schema object.
	// Required.
	Schema        Schema                 `json:"schema"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalBodyParameter BodyParameter

var ignoreKeysBodyParameter = []string{
	"description",
	"name",
	"required",
	"schema",
	"in",
}

// UnmarshalJSON decodes JSON.
func (b *BodyParameter) UnmarshalJSON(data []byte) error {
	var err error

	mb := marshalBodyParameter(*b)

	err = json.Unmarshal(data, &mb)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["in"]; !ok || string(v) != `"body"` {
		return fmt.Errorf(`bad or missing const value for "in" ("body" expected, %s received)`, v)
	}

	delete(rawMap, "in")

	for _, key := range ignoreKeysBodyParameter {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mb.MapOfAnything == nil {
				mb.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mb.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*b = BodyParameter(mb)

	return nil
}

var (
	// constBodyParameter is unconditionally added to JSON.
	constBodyParameter = json.RawMessage(`{"in":"body"}`)
)

// MarshalJSON encodes JSON.
func (b BodyParameter) MarshalJSON() ([]byte, error) {
	return marshalUnion(constBodyParameter, marshalBodyParameter(b), b.MapOfAnything)
}

// Schema structure is generated from "#/definitions/schema".
//
// A deterministic version of a JSON Schema object.
type Schema struct {
	Ref                  string                                        `json:"$ref,omitempty"`
	Format               string                                        `json:"format,omitempty"`
	Title                string                                        `json:"title,omitempty"`
	Description          string                                        `json:"description,omitempty"`
	Default              *interface{}                                  `json:"default,omitempty"`
	MultipleOf           float64                                       `json:"multipleOf,omitempty"`
	Maximum              float64                                       `json:"maximum,omitempty"`
	ExclusiveMaximum     bool                                          `json:"exclusiveMaximum,omitempty"`
	Minimum              float64                                       `json:"minimum,omitempty"`
	ExclusiveMinimum     bool                                          `json:"exclusiveMinimum,omitempty"`
	MaxLength            int64                                         `json:"maxLength,omitempty"`
	MinLength            int64                                         `json:"minLength,omitempty"`
	Pattern              string                                        `json:"pattern,omitempty"`              // Format: regex.
	MaxItems             int64                                         `json:"maxItems,omitempty"`
	MinItems             int64                                         `json:"minItems,omitempty"`
	UniqueItems          bool                                          `json:"uniqueItems,omitempty"`
	MaxProperties        int64                                         `json:"maxProperties,omitempty"`
	MinProperties        int64                                         `json:"minProperties,omitempty"`
	Required             []string                                      `json:"required,omitempty"`
	Enum                 []interface{}                                 `json:"enum,omitempty"`
	AdditionalProperties *SchemaAdditionalProperties                   `json:"additionalProperties,omitempty"`
	Type                 *HTTPJSONSchemaOrgDraft04SchemaPropertiesType `json:"type,omitempty"`
	Items                *SchemaItems                                  `json:"items,omitempty"`
	AllOf                []Schema                                      `json:"allOf,omitempty"`
	Properties           map[string]Schema                             `json:"properties,omitempty"`
	Discriminator        string                                        `json:"discriminator,omitempty"`
	ReadOnly             bool                                          `json:"readOnly,omitempty"`
	XML                  *XML                                          `json:"xml,omitempty"`
	ExternalDocs         *ExternalDocs                                 `json:"externalDocs,omitempty"`         // Information about external documentation.
	Example              *interface{}                                  `json:"example,omitempty"`
	MapOfAnything        map[string]interface{}                        `json:"-"`                              // Key must match pattern: `^x-`.
}

type marshalSchema Schema

var ignoreKeysSchema = []string{
	"$ref",
	"format",
	"title",
	"description",
	"default",
	"multipleOf",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"maxProperties",
	"minProperties",
	"required",
	"enum",
	"additionalProperties",
	"type",
	"items",
	"allOf",
	"properties",
	"discriminator",
	"readOnly",
	"xml",
	"externalDocs",
	"example",
}

// UnmarshalJSON decodes JSON.
func (s *Schema) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSchema(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if ms.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			ms.Default = &v
		}
	}

	if ms.Example == nil {
		if _, ok := rawMap["example"]; ok {
			var v interface{}
			ms.Example = &v
		}
	}

	for _, key := range ignoreKeysSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*s = Schema(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s Schema) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalSchema(s), s.MapOfAnything)
}

// SchemaAdditionalProperties structure is generated from "#/definitions/schema->additionalProperties".
type SchemaAdditionalProperties struct {
	Schema *Schema `json:"-"`
	Bool   *bool   `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (s *SchemaAdditionalProperties) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &s.Schema)
	if err != nil {
		s.Schema = nil
	}

	err = json.Unmarshal(data, &s.Bool)
	if err != nil {
		s.Bool = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SchemaAdditionalProperties) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.Schema, s.Bool)
}

// HTTPJSONSchemaOrgDraft04SchemaPropertiesType structure is generated from "http://json-schema.org/draft-04/schema#/properties/type".
type HTTPJSONSchemaOrgDraft04SchemaPropertiesType struct {
	SimpleTypes              *SimpleTypes  `json:"-"`
	SliceOfSimpleTypesValues []SimpleTypes `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (h *HTTPJSONSchemaOrgDraft04SchemaPropertiesType) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &h.SimpleTypes)
	if err != nil {
		h.SimpleTypes = nil
	}

	err = json.Unmarshal(data, &h.SliceOfSimpleTypesValues)
	if err != nil {
		h.SliceOfSimpleTypesValues = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (h HTTPJSONSchemaOrgDraft04SchemaPropertiesType) MarshalJSON() ([]byte, error) {
	return marshalUnion(h.SimpleTypes, h.SliceOfSimpleTypesValues)
}

// SchemaItems structure is generated from "#/definitions/schema->items".
type SchemaItems struct {
	Schema              *Schema  `json:"-"`
	SliceOfSchemaValues []Schema `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (s *SchemaItems) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &s.Schema)
	if err != nil {
		s.Schema = nil
	}

	err = json.Unmarshal(data, &s.SliceOfSchemaValues)
	if err != nil {
		s.SliceOfSchemaValues = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SchemaItems) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.Schema, s.SliceOfSchemaValues)
}

// XML structure is generated from "#/definitions/xml".
type XML struct {
	Name          string                 `json:"name,omitempty"`
	Namespace     string                 `json:"namespace,omitempty"`
	Prefix        string                 `json:"prefix,omitempty"`
	Attribute     bool                   `json:"attribute,omitempty"`
	Wrapped       bool                   `json:"wrapped,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                   // Key must match pattern: `^x-`.
}

type marshalXML XML

var ignoreKeysXML = []string{
	"name",
	"namespace",
	"prefix",
	"attribute",
	"wrapped",
}

// UnmarshalJSON decodes JSON.
func (x *XML) UnmarshalJSON(data []byte) error {
	var err error

	mx := marshalXML(*x)

	err = json.Unmarshal(data, &mx)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysXML {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mx.MapOfAnything == nil {
				mx.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mx.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*x = XML(mx)

	return nil
}

// MarshalJSON encodes JSON.
func (x XML) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalXML(x), x.MapOfAnything)
}

// HeaderParameterSubSchema structure is generated from "#/definitions/headerParameterSubSchema".
type HeaderParameterSubSchema struct {
	Required         bool                         `json:"required,omitempty"`         // Determines whether or not this parameter is required or optional.
	Description      string                       `json:"description,omitempty"`      // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Name             string                       `json:"name,omitempty"`             // The name of the parameter.
	Type             HeaderParameterSubSchemaType `json:"type,omitempty"`
	Format           string                       `json:"format,omitempty"`
	Items            *PrimitivesItems             `json:"items,omitempty"`
	CollectionFormat CollectionFormat             `json:"collectionFormat,omitempty"`
	Default          *interface{}                 `json:"default,omitempty"`
	Maximum          float64                      `json:"maximum,omitempty"`
	ExclusiveMaximum bool                         `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                      `json:"minimum,omitempty"`
	ExclusiveMinimum bool                         `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                        `json:"maxLength,omitempty"`
	MinLength        int64                        `json:"minLength,omitempty"`
	Pattern          string                       `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                        `json:"maxItems,omitempty"`
	MinItems         int64                        `json:"minItems,omitempty"`
	UniqueItems      bool                         `json:"uniqueItems,omitempty"`
	Enum             []interface{}                `json:"enum,omitempty"`
	MultipleOf       float64                      `json:"multipleOf,omitempty"`
	MapOfAnything    map[string]interface{}       `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalHeaderParameterSubSchema HeaderParameterSubSchema

var ignoreKeysHeaderParameterSubSchema = []string{
	"required",
	"description",
	"name",
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
	"in",
}

// UnmarshalJSON decodes JSON.
func (h *HeaderParameterSubSchema) UnmarshalJSON(data []byte) error {
	var err error

	mh := marshalHeaderParameterSubSchema(*h)

	err = json.Unmarshal(data, &mh)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["in"]; !ok || string(v) != `"header"` {
		return fmt.Errorf(`bad or missing const value for "in" ("header" expected, %s received)`, v)
	}

	delete(rawMap, "in")

	if mh.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mh.Default = &v
		}
	}

	for _, key := range ignoreKeysHeaderParameterSubSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mh.MapOfAnything == nil {
				mh.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mh.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*h = HeaderParameterSubSchema(mh)

	return nil
}

var (
	// constHeaderParameterSubSchema is unconditionally added to JSON.
	constHeaderParameterSubSchema = json.RawMessage(`{"in":"header"}`)
)

// MarshalJSON encodes JSON.
func (h HeaderParameterSubSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constHeaderParameterSubSchema, marshalHeaderParameterSubSchema(h), h.MapOfAnything)
}

// PrimitivesItems structure is generated from "#/definitions/primitivesItems".
type PrimitivesItems struct {
	Type             PrimitivesItemsType    `json:"type,omitempty"`
	Format           string                 `json:"format,omitempty"`
	Items            *PrimitivesItems       `json:"items,omitempty"`
	CollectionFormat CollectionFormat       `json:"collectionFormat,omitempty"`
	Default          *interface{}           `json:"default,omitempty"`
	Maximum          float64                `json:"maximum,omitempty"`
	ExclusiveMaximum bool                   `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                `json:"minimum,omitempty"`
	ExclusiveMinimum bool                   `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                  `json:"maxLength,omitempty"`
	MinLength        int64                  `json:"minLength,omitempty"`
	Pattern          string                 `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                  `json:"maxItems,omitempty"`
	MinItems         int64                  `json:"minItems,omitempty"`
	UniqueItems      bool                   `json:"uniqueItems,omitempty"`
	Enum             []interface{}          `json:"enum,omitempty"`
	MultipleOf       float64                `json:"multipleOf,omitempty"`
	MapOfAnything    map[string]interface{} `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalPrimitivesItems PrimitivesItems

var ignoreKeysPrimitivesItems = []string{
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
}

// UnmarshalJSON decodes JSON.
func (p *PrimitivesItems) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalPrimitivesItems(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mp.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mp.Default = &v
		}
	}

	for _, key := range ignoreKeysPrimitivesItems {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mp.MapOfAnything == nil {
				mp.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mp.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*p = PrimitivesItems(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p PrimitivesItems) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalPrimitivesItems(p), p.MapOfAnything)
}

// FormDataParameterSubSchema structure is generated from "#/definitions/formDataParameterSubSchema".
type FormDataParameterSubSchema struct {
	Required         bool                           `json:"required,omitempty"`         // Determines whether or not this parameter is required or optional.
	Description      string                         `json:"description,omitempty"`      // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Name             string                         `json:"name,omitempty"`             // The name of the parameter.
	AllowEmptyValue  bool                           `json:"allowEmptyValue,omitempty"`  // Allows sending a parameter by name only or with an empty value.
	Type             FormDataParameterSubSchemaType `json:"type,omitempty"`
	Format           string                         `json:"format,omitempty"`
	Items            *PrimitivesItems               `json:"items,omitempty"`
	CollectionFormat CollectionFormatWithMulti      `json:"collectionFormat,omitempty"`
	Default          *interface{}                   `json:"default,omitempty"`
	Maximum          float64                        `json:"maximum,omitempty"`
	ExclusiveMaximum bool                           `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                        `json:"minimum,omitempty"`
	ExclusiveMinimum bool                           `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                          `json:"maxLength,omitempty"`
	MinLength        int64                          `json:"minLength,omitempty"`
	Pattern          string                         `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                          `json:"maxItems,omitempty"`
	MinItems         int64                          `json:"minItems,omitempty"`
	UniqueItems      bool                           `json:"uniqueItems,omitempty"`
	Enum             []interface{}                  `json:"enum,omitempty"`
	MultipleOf       float64                        `json:"multipleOf,omitempty"`
	MapOfAnything    map[string]interface{}         `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalFormDataParameterSubSchema FormDataParameterSubSchema

var ignoreKeysFormDataParameterSubSchema = []string{
	"required",
	"description",
	"name",
	"allowEmptyValue",
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
	"in",
}

// UnmarshalJSON decodes JSON.
func (f *FormDataParameterSubSchema) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFormDataParameterSubSchema(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["in"]; !ok || string(v) != `"formData"` {
		return fmt.Errorf(`bad or missing const value for "in" ("formData" expected, %s received)`, v)
	}

	delete(rawMap, "in")

	if mf.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mf.Default = &v
		}
	}

	for _, key := range ignoreKeysFormDataParameterSubSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mf.MapOfAnything == nil {
				mf.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mf.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*f = FormDataParameterSubSchema(mf)

	return nil
}

var (
	// constFormDataParameterSubSchema is unconditionally added to JSON.
	constFormDataParameterSubSchema = json.RawMessage(`{"in":"formData"}`)
)

// MarshalJSON encodes JSON.
func (f FormDataParameterSubSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constFormDataParameterSubSchema, marshalFormDataParameterSubSchema(f), f.MapOfAnything)
}

// QueryParameterSubSchema structure is generated from "#/definitions/queryParameterSubSchema".
type QueryParameterSubSchema struct {
	Required         bool                        `json:"required,omitempty"`         // Determines whether or not this parameter is required or optional.
	Description      string                      `json:"description,omitempty"`      // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Name             string                      `json:"name,omitempty"`             // The name of the parameter.
	AllowEmptyValue  bool                        `json:"allowEmptyValue,omitempty"`  // Allows sending a parameter by name only or with an empty value.
	Type             QueryParameterSubSchemaType `json:"type,omitempty"`
	Format           string                      `json:"format,omitempty"`
	Items            *PrimitivesItems            `json:"items,omitempty"`
	CollectionFormat CollectionFormatWithMulti   `json:"collectionFormat,omitempty"`
	Default          *interface{}                `json:"default,omitempty"`
	Maximum          float64                     `json:"maximum,omitempty"`
	ExclusiveMaximum bool                        `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                     `json:"minimum,omitempty"`
	ExclusiveMinimum bool                        `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                       `json:"maxLength,omitempty"`
	MinLength        int64                       `json:"minLength,omitempty"`
	Pattern          string                      `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                       `json:"maxItems,omitempty"`
	MinItems         int64                       `json:"minItems,omitempty"`
	UniqueItems      bool                        `json:"uniqueItems,omitempty"`
	Enum             []interface{}               `json:"enum,omitempty"`
	MultipleOf       float64                     `json:"multipleOf,omitempty"`
	MapOfAnything    map[string]interface{}      `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalQueryParameterSubSchema QueryParameterSubSchema

var ignoreKeysQueryParameterSubSchema = []string{
	"required",
	"description",
	"name",
	"allowEmptyValue",
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
	"in",
}

// UnmarshalJSON decodes JSON.
func (q *QueryParameterSubSchema) UnmarshalJSON(data []byte) error {
	var err error

	mq := marshalQueryParameterSubSchema(*q)

	err = json.Unmarshal(data, &mq)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["in"]; !ok || string(v) != `"query"` {
		return fmt.Errorf(`bad or missing const value for "in" ("query" expected, %s received)`, v)
	}

	delete(rawMap, "in")

	if mq.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mq.Default = &v
		}
	}

	for _, key := range ignoreKeysQueryParameterSubSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mq.MapOfAnything == nil {
				mq.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mq.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*q = QueryParameterSubSchema(mq)

	return nil
}

var (
	// constQueryParameterSubSchema is unconditionally added to JSON.
	constQueryParameterSubSchema = json.RawMessage(`{"in":"query"}`)
)

// MarshalJSON encodes JSON.
func (q QueryParameterSubSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constQueryParameterSubSchema, marshalQueryParameterSubSchema(q), q.MapOfAnything)
}

// PathParameterSubSchema structure is generated from "#/definitions/pathParameterSubSchema".
type PathParameterSubSchema struct {
	Description      string                     `json:"description,omitempty"`      // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Name             string                     `json:"name,omitempty"`             // The name of the parameter.
	Type             PathParameterSubSchemaType `json:"type,omitempty"`
	Format           string                     `json:"format,omitempty"`
	Items            *PrimitivesItems           `json:"items,omitempty"`
	CollectionFormat CollectionFormat           `json:"collectionFormat,omitempty"`
	Default          *interface{}               `json:"default,omitempty"`
	Maximum          float64                    `json:"maximum,omitempty"`
	ExclusiveMaximum bool                       `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                    `json:"minimum,omitempty"`
	ExclusiveMinimum bool                       `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                      `json:"maxLength,omitempty"`
	MinLength        int64                      `json:"minLength,omitempty"`
	Pattern          string                     `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                      `json:"maxItems,omitempty"`
	MinItems         int64                      `json:"minItems,omitempty"`
	UniqueItems      bool                       `json:"uniqueItems,omitempty"`
	Enum             []interface{}              `json:"enum,omitempty"`
	MultipleOf       float64                    `json:"multipleOf,omitempty"`
	MapOfAnything    map[string]interface{}     `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalPathParameterSubSchema PathParameterSubSchema

var ignoreKeysPathParameterSubSchema = []string{
	"description",
	"name",
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
	"required",
	"in",
}

// UnmarshalJSON decodes JSON.
func (p *PathParameterSubSchema) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalPathParameterSubSchema(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["required"]; !ok || string(v) != "true" {
		return fmt.Errorf(`bad or missing const value for "required" (true expected, %s received)`, v)
	}

	delete(rawMap, "required")

	if v, ok := rawMap["in"]; !ok || string(v) != `"path"` {
		return fmt.Errorf(`bad or missing const value for "in" ("path" expected, %s received)`, v)
	}

	delete(rawMap, "in")

	if mp.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mp.Default = &v
		}
	}

	for _, key := range ignoreKeysPathParameterSubSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mp.MapOfAnything == nil {
				mp.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mp.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*p = PathParameterSubSchema(mp)

	return nil
}

var (
	// constPathParameterSubSchema is unconditionally added to JSON.
	constPathParameterSubSchema = json.RawMessage(`{"required":true,"in":"path"}`)
)

// MarshalJSON encodes JSON.
func (p PathParameterSubSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constPathParameterSubSchema, marshalPathParameterSubSchema(p), p.MapOfAnything)
}

// NonBodyParameter structure is generated from "#/definitions/nonBodyParameter".
type NonBodyParameter struct {
	HeaderParameterSubSchema   *HeaderParameterSubSchema   `json:"-"`
	FormDataParameterSubSchema *FormDataParameterSubSchema `json:"-"`
	QueryParameterSubSchema    *QueryParameterSubSchema    `json:"-"`
	PathParameterSubSchema     *PathParameterSubSchema     `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (n *NonBodyParameter) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &n.HeaderParameterSubSchema)
	if err != nil {
		n.HeaderParameterSubSchema = nil
	}

	err = json.Unmarshal(data, &n.FormDataParameterSubSchema)
	if err != nil {
		n.FormDataParameterSubSchema = nil
	}

	err = json.Unmarshal(data, &n.QueryParameterSubSchema)
	if err != nil {
		n.QueryParameterSubSchema = nil
	}

	err = json.Unmarshal(data, &n.PathParameterSubSchema)
	if err != nil {
		n.PathParameterSubSchema = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (n NonBodyParameter) MarshalJSON() ([]byte, error) {
	return marshalUnion(n.HeaderParameterSubSchema, n.FormDataParameterSubSchema, n.QueryParameterSubSchema, n.PathParameterSubSchema)
}

// Parameter structure is generated from "#/definitions/parameter".
type Parameter struct {
	BodyParameter    *BodyParameter    `json:"-"`
	NonBodyParameter *NonBodyParameter `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (p *Parameter) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &p.BodyParameter)
	if err != nil {
		p.BodyParameter = nil
	}

	err = json.Unmarshal(data, &p.NonBodyParameter)
	if err != nil {
		p.NonBodyParameter = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (p Parameter) MarshalJSON() ([]byte, error) {
	return marshalUnion(p.BodyParameter, p.NonBodyParameter)
}

// JSONReference structure is generated from "#/definitions/jsonReference".
type JSONReference struct {
	Ref string `json:"$ref"` // Required.
}

// ParametersListItems structure is generated from "#/definitions/parametersList->items".
type ParametersListItems struct {
	Parameter     *Parameter     `json:"-"`
	JSONReference *JSONReference `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (p *ParametersListItems) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &p.Parameter)
	if err != nil {
		p.Parameter = nil
	}

	err = json.Unmarshal(data, &p.JSONReference)
	if err != nil {
		p.JSONReference = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (p ParametersListItems) MarshalJSON() ([]byte, error) {
	return marshalUnion(p.Parameter, p.JSONReference)
}

// Response structure is generated from "#/definitions/response".
type Response struct {
	Description   string                 `json:"description"`        // Required.
	Schema        *ResponseSchema        `json:"schema,omitempty"`
	Headers       map[string]Header      `json:"headers,omitempty"`
	Examples      map[string]interface{} `json:"examples,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                  // Key must match pattern: `^x-`.
}

type marshalResponse Response

var ignoreKeysResponse = []string{
	"description",
	"schema",
	"headers",
	"examples",
}

// UnmarshalJSON decodes JSON.
func (r *Response) UnmarshalJSON(data []byte) error {
	var err error

	mr := marshalResponse(*r)

	err = json.Unmarshal(data, &mr)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysResponse {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mr.MapOfAnything == nil {
				mr.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mr.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*r = Response(mr)

	return nil
}

// MarshalJSON encodes JSON.
func (r Response) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalResponse(r), r.MapOfAnything)
}

// FileSchema structure is generated from "#/definitions/fileSchema".
//
// A deterministic version of a JSON Schema object.
type FileSchema struct {
	Format        string                 `json:"format,omitempty"`
	Title         string                 `json:"title,omitempty"`
	Description   string                 `json:"description,omitempty"`
	Default       *interface{}           `json:"default,omitempty"`
	Required      []string               `json:"required,omitempty"`
	ReadOnly      bool                   `json:"readOnly,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	Example       *interface{}           `json:"example,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-`.
}

type marshalFileSchema FileSchema

var ignoreKeysFileSchema = []string{
	"format",
	"title",
	"description",
	"default",
	"required",
	"readOnly",
	"externalDocs",
	"example",
	"type",
}

// UnmarshalJSON decodes JSON.
func (f *FileSchema) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFileSchema(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"file"` {
		return fmt.Errorf(`bad or missing const value for "type" ("file" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if mf.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mf.Default = &v
		}
	}

	if mf.Example == nil {
		if _, ok := rawMap["example"]; ok {
			var v interface{}
			mf.Example = &v
		}
	}

	for _, key := range ignoreKeysFileSchema {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mf.MapOfAnything == nil {
				mf.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mf.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*f = FileSchema(mf)

	return nil
}

var (
	// constFileSchema is unconditionally added to JSON.
	constFileSchema = json.RawMessage(`{"type":"file"}`)
)

// MarshalJSON encodes JSON.
func (f FileSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(constFileSchema, marshalFileSchema(f), f.MapOfAnything)
}

// ResponseSchema structure is generated from "#/definitions/response->schema".
type ResponseSchema struct {
	Schema     *Schema     `json:"-"`
	FileSchema *FileSchema `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (r *ResponseSchema) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &r.Schema)
	if err != nil {
		r.Schema = nil
	}

	err = json.Unmarshal(data, &r.FileSchema)
	if err != nil {
		r.FileSchema = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (r ResponseSchema) MarshalJSON() ([]byte, error) {
	return marshalUnion(r.Schema, r.FileSchema)
}

// Header structure is generated from "#/definitions/header".
type Header struct {
	Type             HeaderType             `json:"type"`                       // Required.
	Format           string                 `json:"format,omitempty"`
	Items            *PrimitivesItems       `json:"items,omitempty"`
	CollectionFormat CollectionFormat       `json:"collectionFormat,omitempty"`
	Default          *interface{}           `json:"default,omitempty"`
	Maximum          float64                `json:"maximum,omitempty"`
	ExclusiveMaximum bool                   `json:"exclusiveMaximum,omitempty"`
	Minimum          float64                `json:"minimum,omitempty"`
	ExclusiveMinimum bool                   `json:"exclusiveMinimum,omitempty"`
	MaxLength        int64                  `json:"maxLength,omitempty"`
	MinLength        int64                  `json:"minLength,omitempty"`
	Pattern          string                 `json:"pattern,omitempty"`          // Format: regex.
	MaxItems         int64                  `json:"maxItems,omitempty"`
	MinItems         int64                  `json:"minItems,omitempty"`
	UniqueItems      bool                   `json:"uniqueItems,omitempty"`
	Enum             []interface{}          `json:"enum,omitempty"`
	MultipleOf       float64                `json:"multipleOf,omitempty"`
	Description      string                 `json:"description,omitempty"`
	MapOfAnything    map[string]interface{} `json:"-"`                          // Key must match pattern: `^x-`.
}

type marshalHeader Header

var ignoreKeysHeader = []string{
	"type",
	"format",
	"items",
	"collectionFormat",
	"default",
	"maximum",
	"exclusiveMaximum",
	"minimum",
	"exclusiveMinimum",
	"maxLength",
	"minLength",
	"pattern",
	"maxItems",
	"minItems",
	"uniqueItems",
	"enum",
	"multipleOf",
	"description",
}

// UnmarshalJSON decodes JSON.
func (h *Header) UnmarshalJSON(data []byte) error {
	var err error

	mh := marshalHeader(*h)

	err = json.Unmarshal(data, &mh)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mh.Default == nil {
		if _, ok := rawMap["default"]; ok {
			var v interface{}
			mh.Default = &v
		}
	}

	for _, key := range ignoreKeysHeader {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mh.MapOfAnything == nil {
				mh.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mh.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*h = Header(mh)

	return nil
}

// MarshalJSON encodes JSON.
func (h Header) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalHeader(h), h.MapOfAnything)
}

// ResponseValue structure is generated from "#/definitions/responseValue".
type ResponseValue struct {
	Response      *Response      `json:"-"`
	JSONReference *JSONReference `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (r *ResponseValue) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &r.Response)
	if err != nil {
		r.Response = nil
	}

	err = json.Unmarshal(data, &r.JSONReference)
	if err != nil {
		r.JSONReference = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (r ResponseValue) MarshalJSON() ([]byte, error) {
	return marshalUnion(r.Response, r.JSONReference)
}

// Responses structure is generated from "#/definitions/responses".
//
// Response objects names can either be any valid HTTP status code or 'default'.
type Responses struct {
	MapOfResponseValueValues map[string]ResponseValue `json:"-"` // Key must match pattern: `^([0-9]{3})$|^(default)$`.
	MapOfAnything            map[string]interface{}   `json:"-"` // Key must match pattern: `^x-`.
}

// UnmarshalJSON decodes JSON.
func (r *Responses) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regex093Default.MatchString(key) {
			matched = true

			if r.MapOfResponseValueValues == nil {
				r.MapOfResponseValueValues = make(map[string]ResponseValue, 1)
			}

			var val ResponseValue

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			r.MapOfResponseValueValues[key] = val
		}

		if regexX.MatchString(key) {
			matched = true

			if r.MapOfAnything == nil {
				r.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			r.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (r Responses) MarshalJSON() ([]byte, error) {
	return marshalUnion(r.MapOfResponseValueValues, r.MapOfAnything)
}

// BasicAuthenticationSecurity structure is generated from "#/definitions/basicAuthenticationSecurity".
type BasicAuthenticationSecurity struct {
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalBasicAuthenticationSecurity BasicAuthenticationSecurity

var ignoreKeysBasicAuthenticationSecurity = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (b *BasicAuthenticationSecurity) UnmarshalJSON(data []byte) error {
	var err error

	mb := marshalBasicAuthenticationSecurity(*b)

	err = json.Unmarshal(data, &mb)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"basic"` {
		return fmt.Errorf(`bad or missing const value for "type" ("basic" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range ignoreKeysBasicAuthenticationSecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mb.MapOfAnything == nil {
				mb.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mb.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*b = BasicAuthenticationSecurity(mb)

	return nil
}

var (
	// constBasicAuthenticationSecurity is unconditionally added to JSON.
	constBasicAuthenticationSecurity = json.RawMessage(`{"type":"basic"}`)
)

// MarshalJSON encodes JSON.
func (b BasicAuthenticationSecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constBasicAuthenticationSecurity, marshalBasicAuthenticationSecurity(b), b.MapOfAnything)
}

// APIKeySecurity structure is generated from "#/definitions/apiKeySecurity".
type APIKeySecurity struct {
	Name          string                 `json:"name"`                  // Required.
	In            APIKeySecurityIn       `json:"in"`                    // Required.
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalAPIKeySecurity APIKeySecurity

var ignoreKeysAPIKeySecurity = []string{
	"name",
	"in",
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (a *APIKeySecurity) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAPIKeySecurity(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"apiKey"` {
		return fmt.Errorf(`bad or missing const value for "type" ("apiKey" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range ignoreKeysAPIKeySecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*a = APIKeySecurity(ma)

	return nil
}

var (
	// constAPIKeySecurity is unconditionally added to JSON.
	constAPIKeySecurity = json.RawMessage(`{"type":"apiKey"}`)
)

// MarshalJSON encodes JSON.
func (a APIKeySecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAPIKeySecurity, marshalAPIKeySecurity(a), a.MapOfAnything)
}

// Oauth2ImplicitSecurity structure is generated from "#/definitions/oauth2ImplicitSecurity".
type Oauth2ImplicitSecurity struct {
	Scopes           map[string]string      `json:"scopes,omitempty"`
	// Format: uri.
	// Required.
	AuthorizationURL string                 `json:"authorizationUrl"`
	Description      string                 `json:"description,omitempty"`
	MapOfAnything    map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalOauth2ImplicitSecurity Oauth2ImplicitSecurity

var ignoreKeysOauth2ImplicitSecurity = []string{
	"scopes",
	"authorizationUrl",
	"description",
	"type",
	"flow",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2ImplicitSecurity) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2ImplicitSecurity(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"oauth2"` {
		return fmt.Errorf(`bad or missing const value for "type" ("oauth2" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if v, ok := rawMap["flow"]; !ok || string(v) != `"implicit"` {
		return fmt.Errorf(`bad or missing const value for "flow" ("implicit" expected, %s received)`, v)
	}

	delete(rawMap, "flow")

	for _, key := range ignoreKeysOauth2ImplicitSecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Oauth2ImplicitSecurity(mo)

	return nil
}

var (
	// constOauth2ImplicitSecurity is unconditionally added to JSON.
	constOauth2ImplicitSecurity = json.RawMessage(`{"type":"oauth2","flow":"implicit"}`)
)

// MarshalJSON encodes JSON.
func (o Oauth2ImplicitSecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOauth2ImplicitSecurity, marshalOauth2ImplicitSecurity(o), o.MapOfAnything)
}

// Oauth2PasswordSecurity structure is generated from "#/definitions/oauth2PasswordSecurity".
type Oauth2PasswordSecurity struct {
	Scopes        map[string]string      `json:"scopes,omitempty"`
	// Format: uri.
	// Required.
	TokenURL      string                 `json:"tokenUrl"`
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalOauth2PasswordSecurity Oauth2PasswordSecurity

var ignoreKeysOauth2PasswordSecurity = []string{
	"scopes",
	"tokenUrl",
	"description",
	"type",
	"flow",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2PasswordSecurity) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2PasswordSecurity(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"oauth2"` {
		return fmt.Errorf(`bad or missing const value for "type" ("oauth2" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if v, ok := rawMap["flow"]; !ok || string(v) != `"password"` {
		return fmt.Errorf(`bad or missing const value for "flow" ("password" expected, %s received)`, v)
	}

	delete(rawMap, "flow")

	for _, key := range ignoreKeysOauth2PasswordSecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Oauth2PasswordSecurity(mo)

	return nil
}

var (
	// constOauth2PasswordSecurity is unconditionally added to JSON.
	constOauth2PasswordSecurity = json.RawMessage(`{"type":"oauth2","flow":"password"}`)
)

// MarshalJSON encodes JSON.
func (o Oauth2PasswordSecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOauth2PasswordSecurity, marshalOauth2PasswordSecurity(o), o.MapOfAnything)
}

// Oauth2ApplicationSecurity structure is generated from "#/definitions/oauth2ApplicationSecurity".
type Oauth2ApplicationSecurity struct {
	Scopes        map[string]string      `json:"scopes,omitempty"`
	// Format: uri.
	// Required.
	TokenURL      string                 `json:"tokenUrl"`
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalOauth2ApplicationSecurity Oauth2ApplicationSecurity

var ignoreKeysOauth2ApplicationSecurity = []string{
	"scopes",
	"tokenUrl",
	"description",
	"type",
	"flow",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2ApplicationSecurity) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2ApplicationSecurity(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"oauth2"` {
		return fmt.Errorf(`bad or missing const value for "type" ("oauth2" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if v, ok := rawMap["flow"]; !ok || string(v) != `"application"` {
		return fmt.Errorf(`bad or missing const value for "flow" ("application" expected, %s received)`, v)
	}

	delete(rawMap, "flow")

	for _, key := range ignoreKeysOauth2ApplicationSecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Oauth2ApplicationSecurity(mo)

	return nil
}

var (
	// constOauth2ApplicationSecurity is unconditionally added to JSON.
	constOauth2ApplicationSecurity = json.RawMessage(`{"type":"oauth2","flow":"application"}`)
)

// MarshalJSON encodes JSON.
func (o Oauth2ApplicationSecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOauth2ApplicationSecurity, marshalOauth2ApplicationSecurity(o), o.MapOfAnything)
}

// Oauth2AccessCodeSecurity structure is generated from "#/definitions/oauth2AccessCodeSecurity".
type Oauth2AccessCodeSecurity struct {
	Scopes           map[string]string      `json:"scopes,omitempty"`
	// Format: uri.
	// Required.
	AuthorizationURL string                 `json:"authorizationUrl"`
	// Format: uri.
	// Required.
	TokenURL         string                 `json:"tokenUrl"`
	Description      string                 `json:"description,omitempty"`
	MapOfAnything    map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-`.
}

type marshalOauth2AccessCodeSecurity Oauth2AccessCodeSecurity

var ignoreKeysOauth2AccessCodeSecurity = []string{
	"scopes",
	"authorizationUrl",
	"tokenUrl",
	"description",
	"type",
	"flow",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2AccessCodeSecurity) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2AccessCodeSecurity(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"oauth2"` {
		return fmt.Errorf(`bad or missing const value for "type" ("oauth2" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if v, ok := rawMap["flow"]; !ok || string(v) != `"accessCode"` {
		return fmt.Errorf(`bad or missing const value for "flow" ("accessCode" expected, %s received)`, v)
	}

	delete(rawMap, "flow")

	for _, key := range ignoreKeysOauth2AccessCodeSecurity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Oauth2AccessCodeSecurity(mo)

	return nil
}

var (
	// constOauth2AccessCodeSecurity is unconditionally added to JSON.
	constOauth2AccessCodeSecurity = json.RawMessage(`{"type":"oauth2","flow":"accessCode"}`)
)

// MarshalJSON encodes JSON.
func (o Oauth2AccessCodeSecurity) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOauth2AccessCodeSecurity, marshalOauth2AccessCodeSecurity(o), o.MapOfAnything)
}

// SecurityDefinitionsAdditionalProperties structure is generated from "#/definitions/securityDefinitions->additionalProperties".
type SecurityDefinitionsAdditionalProperties struct {
	BasicAuthenticationSecurity *BasicAuthenticationSecurity `json:"-"`
	APIKeySecurity              *APIKeySecurity              `json:"-"`
	Oauth2ImplicitSecurity      *Oauth2ImplicitSecurity      `json:"-"`
	Oauth2PasswordSecurity      *Oauth2PasswordSecurity      `json:"-"`
	Oauth2ApplicationSecurity   *Oauth2ApplicationSecurity   `json:"-"`
	Oauth2AccessCodeSecurity    *Oauth2AccessCodeSecurity    `json:"-"`
}

// UnmarshalJSON decodes JSON.
func (s *SecurityDefinitionsAdditionalProperties) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &s.BasicAuthenticationSecurity)
	if err != nil {
		s.BasicAuthenticationSecurity = nil
	}

	err = json.Unmarshal(data, &s.APIKeySecurity)
	if err != nil {
		s.APIKeySecurity = nil
	}

	err = json.Unmarshal(data, &s.Oauth2ImplicitSecurity)
	if err != nil {
		s.Oauth2ImplicitSecurity = nil
	}

	err = json.Unmarshal(data, &s.Oauth2PasswordSecurity)
	if err != nil {
		s.Oauth2PasswordSecurity = nil
	}

	err = json.Unmarshal(data, &s.Oauth2ApplicationSecurity)
	if err != nil {
		s.Oauth2ApplicationSecurity = nil
	}

	err = json.Unmarshal(data, &s.Oauth2AccessCodeSecurity)
	if err != nil {
		s.Oauth2AccessCodeSecurity = nil
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SecurityDefinitionsAdditionalProperties) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.BasicAuthenticationSecurity, s.APIKeySecurity, s.Oauth2ImplicitSecurity, s.Oauth2PasswordSecurity, s.Oauth2ApplicationSecurity, s.Oauth2AccessCodeSecurity)
}

// Tag structure is generated from "#/definitions/tag".
type Tag struct {
	Name          string                 `json:"name"`                   // Required.
	Description   string                 `json:"description,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-`.
}

type marshalTag Tag

var ignoreKeysTag = []string{
	"name",
	"description",
	"externalDocs",
}

// UnmarshalJSON decodes JSON.
func (t *Tag) UnmarshalJSON(data []byte) error {
	var err error

	mt := marshalTag(*t)

	err = json.Unmarshal(data, &mt)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range ignoreKeysTag {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mt.MapOfAnything == nil {
				mt.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mt.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*t = Tag(mt)

	return nil
}

// MarshalJSON encodes JSON.
func (t Tag) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalTag(t), t.MapOfAnything)
}

// SchemesListItems is an enum type.
type SchemesListItems string

// SchemesListItems values enumeration.
const (
	SchemesListItemsHTTP = SchemesListItems("http")
	SchemesListItemsHTTPS = SchemesListItems("https")
	SchemesListItemsWs = SchemesListItems("ws")
	SchemesListItemsWss = SchemesListItems("wss")
)

// MarshalJSON encodes JSON.
func (i SchemesListItems) MarshalJSON() ([]byte, error) {
	switch i {
	case SchemesListItemsHTTP:
	case SchemesListItemsHTTPS:
	case SchemesListItemsWs:
	case SchemesListItemsWss:

	default:
		return nil, fmt.Errorf("unexpected SchemesListItems value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *SchemesListItems) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := SchemesListItems(ii)

	switch v {
	case SchemesListItemsHTTP:
	case SchemesListItemsHTTPS:
	case SchemesListItemsWs:
	case SchemesListItemsWss:

	default:
		return fmt.Errorf("unexpected SchemesListItems value: %v", v)
	}

	*i = v

	return nil
}

// SimpleTypes is an enum type.
type SimpleTypes string

// SimpleTypes values enumeration.
const (
	SimpleTypesArray = SimpleTypes("array")
	SimpleTypesBoolean = SimpleTypes("boolean")
	SimpleTypesInteger = SimpleTypes("integer")
	SimpleTypesNull = SimpleTypes("null")
	SimpleTypesNumber = SimpleTypes("number")
	SimpleTypesObject = SimpleTypes("object")
	SimpleTypesString = SimpleTypes("string")
)

// MarshalJSON encodes JSON.
func (i SimpleTypes) MarshalJSON() ([]byte, error) {
	switch i {
	case SimpleTypesArray:
	case SimpleTypesBoolean:
	case SimpleTypesInteger:
	case SimpleTypesNull:
	case SimpleTypesNumber:
	case SimpleTypesObject:
	case SimpleTypesString:

	default:
		return nil, fmt.Errorf("unexpected SimpleTypes value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *SimpleTypes) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := SimpleTypes(ii)

	switch v {
	case SimpleTypesArray:
	case SimpleTypesBoolean:
	case SimpleTypesInteger:
	case SimpleTypesNull:
	case SimpleTypesNumber:
	case SimpleTypesObject:
	case SimpleTypesString:

	default:
		return fmt.Errorf("unexpected SimpleTypes value: %v", v)
	}

	*i = v

	return nil
}

// HeaderParameterSubSchemaType is an enum type.
type HeaderParameterSubSchemaType string

// HeaderParameterSubSchemaType values enumeration.
const (
	HeaderParameterSubSchemaTypeString = HeaderParameterSubSchemaType("string")
	HeaderParameterSubSchemaTypeNumber = HeaderParameterSubSchemaType("number")
	HeaderParameterSubSchemaTypeBoolean = HeaderParameterSubSchemaType("boolean")
	HeaderParameterSubSchemaTypeInteger = HeaderParameterSubSchemaType("integer")
	HeaderParameterSubSchemaTypeArray = HeaderParameterSubSchemaType("array")
)

// MarshalJSON encodes JSON.
func (i HeaderParameterSubSchemaType) MarshalJSON() ([]byte, error) {
	switch i {
	case HeaderParameterSubSchemaTypeString:
	case HeaderParameterSubSchemaTypeNumber:
	case HeaderParameterSubSchemaTypeBoolean:
	case HeaderParameterSubSchemaTypeInteger:
	case HeaderParameterSubSchemaTypeArray:

	default:
		return nil, fmt.Errorf("unexpected HeaderParameterSubSchemaType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *HeaderParameterSubSchemaType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := HeaderParameterSubSchemaType(ii)

	switch v {
	case HeaderParameterSubSchemaTypeString:
	case HeaderParameterSubSchemaTypeNumber:
	case HeaderParameterSubSchemaTypeBoolean:
	case HeaderParameterSubSchemaTypeInteger:
	case HeaderParameterSubSchemaTypeArray:

	default:
		return fmt.Errorf("unexpected HeaderParameterSubSchemaType value: %v", v)
	}

	*i = v

	return nil
}

// PrimitivesItemsType is an enum type.
type PrimitivesItemsType string

// PrimitivesItemsType values enumeration.
const (
	PrimitivesItemsTypeString = PrimitivesItemsType("string")
	PrimitivesItemsTypeNumber = PrimitivesItemsType("number")
	PrimitivesItemsTypeInteger = PrimitivesItemsType("integer")
	PrimitivesItemsTypeBoolean = PrimitivesItemsType("boolean")
	PrimitivesItemsTypeArray = PrimitivesItemsType("array")
)

// MarshalJSON encodes JSON.
func (i PrimitivesItemsType) MarshalJSON() ([]byte, error) {
	switch i {
	case PrimitivesItemsTypeString:
	case PrimitivesItemsTypeNumber:
	case PrimitivesItemsTypeInteger:
	case PrimitivesItemsTypeBoolean:
	case PrimitivesItemsTypeArray:

	default:
		return nil, fmt.Errorf("unexpected PrimitivesItemsType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *PrimitivesItemsType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := PrimitivesItemsType(ii)

	switch v {
	case PrimitivesItemsTypeString:
	case PrimitivesItemsTypeNumber:
	case PrimitivesItemsTypeInteger:
	case PrimitivesItemsTypeBoolean:
	case PrimitivesItemsTypeArray:

	default:
		return fmt.Errorf("unexpected PrimitivesItemsType value: %v", v)
	}

	*i = v

	return nil
}

// CollectionFormat is an enum type.
type CollectionFormat string

// CollectionFormat values enumeration.
const (
	CollectionFormatCsv = CollectionFormat("csv")
	CollectionFormatSsv = CollectionFormat("ssv")
	CollectionFormatTsv = CollectionFormat("tsv")
	CollectionFormatPipes = CollectionFormat("pipes")
)

// MarshalJSON encodes JSON.
func (i CollectionFormat) MarshalJSON() ([]byte, error) {
	switch i {
	case CollectionFormatCsv:
	case CollectionFormatSsv:
	case CollectionFormatTsv:
	case CollectionFormatPipes:

	default:
		return nil, fmt.Errorf("unexpected CollectionFormat value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *CollectionFormat) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := CollectionFormat(ii)

	switch v {
	case CollectionFormatCsv:
	case CollectionFormatSsv:
	case CollectionFormatTsv:
	case CollectionFormatPipes:

	default:
		return fmt.Errorf("unexpected CollectionFormat value: %v", v)
	}

	*i = v

	return nil
}

// FormDataParameterSubSchemaType is an enum type.
type FormDataParameterSubSchemaType string

// FormDataParameterSubSchemaType values enumeration.
const (
	FormDataParameterSubSchemaTypeString = FormDataParameterSubSchemaType("string")
	FormDataParameterSubSchemaTypeNumber = FormDataParameterSubSchemaType("number")
	FormDataParameterSubSchemaTypeBoolean = FormDataParameterSubSchemaType("boolean")
	FormDataParameterSubSchemaTypeInteger = FormDataParameterSubSchemaType("integer")
	FormDataParameterSubSchemaTypeArray = FormDataParameterSubSchemaType("array")
	FormDataParameterSubSchemaTypeFile = FormDataParameterSubSchemaType("file")
)

// MarshalJSON encodes JSON.
func (i FormDataParameterSubSchemaType) MarshalJSON() ([]byte, error) {
	switch i {
	case FormDataParameterSubSchemaTypeString:
	case FormDataParameterSubSchemaTypeNumber:
	case FormDataParameterSubSchemaTypeBoolean:
	case FormDataParameterSubSchemaTypeInteger:
	case FormDataParameterSubSchemaTypeArray:
	case FormDataParameterSubSchemaTypeFile:

	default:
		return nil, fmt.Errorf("unexpected FormDataParameterSubSchemaType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *FormDataParameterSubSchemaType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := FormDataParameterSubSchemaType(ii)

	switch v {
	case FormDataParameterSubSchemaTypeString:
	case FormDataParameterSubSchemaTypeNumber:
	case FormDataParameterSubSchemaTypeBoolean:
	case FormDataParameterSubSchemaTypeInteger:
	case FormDataParameterSubSchemaTypeArray:
	case FormDataParameterSubSchemaTypeFile:

	default:
		return fmt.Errorf("unexpected FormDataParameterSubSchemaType value: %v", v)
	}

	*i = v

	return nil
}

// CollectionFormatWithMulti is an enum type.
type CollectionFormatWithMulti string

// CollectionFormatWithMulti values enumeration.
const (
	CollectionFormatWithMultiCsv = CollectionFormatWithMulti("csv")
	CollectionFormatWithMultiSsv = CollectionFormatWithMulti("ssv")
	CollectionFormatWithMultiTsv = CollectionFormatWithMulti("tsv")
	CollectionFormatWithMultiPipes = CollectionFormatWithMulti("pipes")
	CollectionFormatWithMultiMulti = CollectionFormatWithMulti("multi")
)

// MarshalJSON encodes JSON.
func (i CollectionFormatWithMulti) MarshalJSON() ([]byte, error) {
	switch i {
	case CollectionFormatWithMultiCsv:
	case CollectionFormatWithMultiSsv:
	case CollectionFormatWithMultiTsv:
	case CollectionFormatWithMultiPipes:
	case CollectionFormatWithMultiMulti:

	default:
		return nil, fmt.Errorf("unexpected CollectionFormatWithMulti value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *CollectionFormatWithMulti) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := CollectionFormatWithMulti(ii)

	switch v {
	case CollectionFormatWithMultiCsv:
	case CollectionFormatWithMultiSsv:
	case CollectionFormatWithMultiTsv:
	case CollectionFormatWithMultiPipes:
	case CollectionFormatWithMultiMulti:

	default:
		return fmt.Errorf("unexpected CollectionFormatWithMulti value: %v", v)
	}

	*i = v

	return nil
}

// QueryParameterSubSchemaType is an enum type.
type QueryParameterSubSchemaType string

// QueryParameterSubSchemaType values enumeration.
const (
	QueryParameterSubSchemaTypeString = QueryParameterSubSchemaType("string")
	QueryParameterSubSchemaTypeNumber = QueryParameterSubSchemaType("number")
	QueryParameterSubSchemaTypeBoolean = QueryParameterSubSchemaType("boolean")
	QueryParameterSubSchemaTypeInteger = QueryParameterSubSchemaType("integer")
	QueryParameterSubSchemaTypeArray = QueryParameterSubSchemaType("array")
)

// MarshalJSON encodes JSON.
func (i QueryParameterSubSchemaType) MarshalJSON() ([]byte, error) {
	switch i {
	case QueryParameterSubSchemaTypeString:
	case QueryParameterSubSchemaTypeNumber:
	case QueryParameterSubSchemaTypeBoolean:
	case QueryParameterSubSchemaTypeInteger:
	case QueryParameterSubSchemaTypeArray:

	default:
		return nil, fmt.Errorf("unexpected QueryParameterSubSchemaType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *QueryParameterSubSchemaType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := QueryParameterSubSchemaType(ii)

	switch v {
	case QueryParameterSubSchemaTypeString:
	case QueryParameterSubSchemaTypeNumber:
	case QueryParameterSubSchemaTypeBoolean:
	case QueryParameterSubSchemaTypeInteger:
	case QueryParameterSubSchemaTypeArray:

	default:
		return fmt.Errorf("unexpected QueryParameterSubSchemaType value: %v", v)
	}

	*i = v

	return nil
}

// PathParameterSubSchemaType is an enum type.
type PathParameterSubSchemaType string

// PathParameterSubSchemaType values enumeration.
const (
	PathParameterSubSchemaTypeString = PathParameterSubSchemaType("string")
	PathParameterSubSchemaTypeNumber = PathParameterSubSchemaType("number")
	PathParameterSubSchemaTypeBoolean = PathParameterSubSchemaType("boolean")
	PathParameterSubSchemaTypeInteger = PathParameterSubSchemaType("integer")
	PathParameterSubSchemaTypeArray = PathParameterSubSchemaType("array")
)

// MarshalJSON encodes JSON.
func (i PathParameterSubSchemaType) MarshalJSON() ([]byte, error) {
	switch i {
	case PathParameterSubSchemaTypeString:
	case PathParameterSubSchemaTypeNumber:
	case PathParameterSubSchemaTypeBoolean:
	case PathParameterSubSchemaTypeInteger:
	case PathParameterSubSchemaTypeArray:

	default:
		return nil, fmt.Errorf("unexpected PathParameterSubSchemaType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *PathParameterSubSchemaType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := PathParameterSubSchemaType(ii)

	switch v {
	case PathParameterSubSchemaTypeString:
	case PathParameterSubSchemaTypeNumber:
	case PathParameterSubSchemaTypeBoolean:
	case PathParameterSubSchemaTypeInteger:
	case PathParameterSubSchemaTypeArray:

	default:
		return fmt.Errorf("unexpected PathParameterSubSchemaType value: %v", v)
	}

	*i = v

	return nil
}

// HeaderType is an enum type.
type HeaderType string

// HeaderType values enumeration.
const (
	HeaderTypeString = HeaderType("string")
	HeaderTypeNumber = HeaderType("number")
	HeaderTypeInteger = HeaderType("integer")
	HeaderTypeBoolean = HeaderType("boolean")
	HeaderTypeArray = HeaderType("array")
)

// MarshalJSON encodes JSON.
func (i HeaderType) MarshalJSON() ([]byte, error) {
	switch i {
	case HeaderTypeString:
	case HeaderTypeNumber:
	case HeaderTypeInteger:
	case HeaderTypeBoolean:
	case HeaderTypeArray:

	default:
		return nil, fmt.Errorf("unexpected HeaderType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *HeaderType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := HeaderType(ii)

	switch v {
	case HeaderTypeString:
	case HeaderTypeNumber:
	case HeaderTypeInteger:
	case HeaderTypeBoolean:
	case HeaderTypeArray:

	default:
		return fmt.Errorf("unexpected HeaderType value: %v", v)
	}

	*i = v

	return nil
}

// APIKeySecurityIn is an enum type.
type APIKeySecurityIn string

// APIKeySecurityIn values enumeration.
const (
	APIKeySecurityInHeader = APIKeySecurityIn("header")
	APIKeySecurityInQuery = APIKeySecurityIn("query")
)

// MarshalJSON encodes JSON.
func (i APIKeySecurityIn) MarshalJSON() ([]byte, error) {
	switch i {
	case APIKeySecurityInHeader:
	case APIKeySecurityInQuery:

	default:
		return nil, fmt.Errorf("unexpected APIKeySecurityIn value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *APIKeySecurityIn) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := APIKeySecurityIn(ii)

	switch v {
	case APIKeySecurityInHeader:
	case APIKeySecurityInQuery:

	default:
		return fmt.Errorf("unexpected APIKeySecurityIn value: %v", v)
	}

	*i = v

	return nil
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := make([]byte, 1, 100)
	result[0] = '{'
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
// Regular expressions for pattern properties.
var (
	regexX = regexp.MustCompile("^x-")
	regex = regexp.MustCompile("^/")
	regex093Default = regexp.MustCompile("^([0-9]{3})$|^(default)$")
)
